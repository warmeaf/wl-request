# wl-request 技术文档

## 项目概述

wl-request 是一个基于 TypeScript 的现代化请求库，采用分层架构设计，提供统一的请求接口和丰富的功能特性。通过适配器模式支持多种请求库（fetch、axios 等），同时提供请求重试、缓存、并行/串行请求、幂等请求等高级功能。

## 核心特性

- **分层架构**：基于 TypeScript，清晰的代码组织结构
- **适配器模式**：完全兼容适配对象（fetch、axios 等），每个适配器是一个独立的包。默认是 fetch 适配器，无需额外安装
- **缓存适配器**：支持多种缓存存储方式（localStorage、内存、IndexedDB），默认使用 localStorage，无需额外安装
- **高级功能**：请求重试、请求缓存、并行请求、串行请求、幂等请求
- **设计原则**：适配器与核心模块的依赖关系遵循依赖倒置原则，提高代码的可维护性和可扩展性
- **测试完善**：完善的单元测试覆盖
- **使用方式**：hook 式使用方式，符合现代前端开发习惯

## 项目文件结构

```
wl-request/
├── packages/
│   ├── core/                    # 核心包
│   │   ├── src/
│   │   │   ├── types/           # 类型定义
│   │   │   ├── interfaces/     # 接口定义
│   │   │   ├── adapters/        # 适配器抽象层
│   │   │   ├── features/        # 功能模块（重试、缓存等）
│   │   │   ├── hooks/           # Hook 实现
│   │   │   └── index.ts         # 入口文件
│   │   ├── tests/               # 单元测试
│   │   └── package.json
│   │
│   ├── adapter-fetch/           # Fetch 适配器（默认）
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── adapter-axios/           # Axios 适配器（可选）
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── cache-adapter-memory/    # 内存缓存适配器
│   │   ├── src/
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   ├── cache-adapter-indexeddb/ # IndexedDB 缓存适配器
│   │   ├── src/
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   └── ...                      # 其他适配器
│
├── docs/                        # 文档目录
│   └── 技术文档.md
│
├── examples/                    # 使用示例
├── tests/                       # 集成测试
├── .husky/                      # Git hooks 目录
├── biome.json                   # Biome 配置
├── commitlint.config.js         # Commitlint 配置
├── .lintstagedrc.js            # Lint-staged 配置
├── tsconfig.json                # TypeScript 配置
├── pnpm-workspace.yaml          # pnpm workspace 配置
└── package.json                 # 根 package.json（monorepo）
```

## 工程化工具

项目采用现代化的工程化工具链，确保代码质量和开发规范。

### 包管理工具

项目强制使用 **pnpm** 作为包管理工具，通过 `only-allow` 确保团队成员使用统一的包管理器。

**安装依赖：**

```bash
pnpm install
```

**package.json 配置：**

```json
{
  "scripts": {
    "preinstall": "npx only-allow pnpm"
  }
}
```

### Biome

使用 **Biome** 进行代码格式化和 lint 检查，Biome 是一个快速的、零配置的代码格式化工具和 linter。

**常用命令：**

```bash
# 格式化代码
pnpm biome format --write .

# 检查代码
pnpm biome check .

# 自动修复问题
pnpm biome check --write .
```

### Commitlint

使用 **Commitlint** 规范 Git commit 消息格式，确保提交信息的一致性和可读性。

**commitlint.config.js 配置：**

```javascript
export default {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat', // 新功能
        'fix', // 修复 bug
        'docs', // 文档变更
        'style', // 代码格式（不影响代码运行的变动）
        'refactor', // 重构（既不是新增功能，也不是修复 bug）
        'perf', // 性能优化
        'test', // 增加测试
        'chore', // 构建过程或辅助工具的变动
        'revert', // 回滚
        'build', // 构建系统或外部依赖的变更
        'ci', // CI 配置文件和脚本的变更
      ],
    ],
    'subject-case': [0],
  },
}
```

**Commit 消息格式：**

```
<type>(<scope>): <subject>

<body>

<footer>
```

**示例：**

```
feat(core): 添加请求重试功能

实现了请求失败后的自动重试机制，支持自定义重试次数和延迟时间

Closes #123
```

### Husky

使用 **Husky** 管理 Git hooks，在提交代码前自动执行代码检查和格式化。

**安装和初始化：**

```bash
pnpm add -D husky
pnpm exec husky init
```

**package.json 配置：**

```json
{
  "scripts": {
    "prepare": "husky"
  }
}
```

**Git hooks 配置：**

`.husky/pre-commit`：

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

pnpm lint-staged
```

`.husky/commit-msg`：

```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

pnpm commitlint --edit $1
```

### Lint-staged

使用 **lint-staged** 只对 Git 暂存区（staged）的文件运行 lint 和格式化，提高提交效率。

**安装：**

```bash
pnpm add -D lint-staged
```

**.lintstagedrc.js 配置：**

```javascript
export default {
  '*.{js,ts,tsx}': ['biome check --write', 'biome format --write'],
  '*.{json,md}': ['biome format --write'],
}
```

**package.json 配置：**

```json
{
  "lint-staged": {
    "*.{js,ts,tsx}": ["biome check --write", "biome format --write"],
    "*.{json,md}": ["biome format --write"]
  }
}
```

### 工作流程

1. **提交代码前**：`pre-commit` hook 自动运行 `lint-staged`，对暂存文件进行格式化和检查
2. **提交消息时**：`commit-msg` hook 自动运行 `commitlint`，验证 commit 消息格式
3. **CI/CD**：在 CI 流程中运行完整的代码检查和测试

### 开发规范

- 使用 `pnpm` 安装和管理依赖
- 提交前代码会自动格式化和检查
- Commit 消息必须符合 Conventional Commits 规范
- 所有代码必须通过 lint 检查才能提交

## 使用示例

### 基础使用

在 Vue 组件中使用，通过钩子函数处理请求的各个阶段：

```vue
<template>
  <div>
    <button @click="handleRefresh">刷新</button>
    <div v-if="loading">加载中...</div>
    <div v-else-if="error">错误: {{ error?.message }}</div>
    <div v-else>
      <ul>
        <li v-for="user in data" :key="user.id">
          {{ user.name }}
        </li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRequest } from 'wl-request'

const data = ref(null)
const loading = ref(false)
const error = ref(null)

const { send } = useRequest({
  url: '/api/users',
  method: 'GET',
  onBefore: () => {
    loading.value = true
    error.value = null
  },
  onSuccess: (response) => {
    data.value = response.data
    loading.value = false
    error.value = null
  },
  onError: (err) => {
    error.value = err
    loading.value = false
  },
  onFinally: () => {
    loading.value = false
  },
})

onMounted(() => {
  send()
})

const handleRefresh = () => {
  send()
}
</script>
```

### 全局配置

在应用启动时配置全局默认设置，所有请求都会继承这些配置：

```typescript
import { configure } from 'wl-request'
import { axiosAdapter } from '@wl-request/adapter-axios'
import { indexedDBAdapter } from 'wl-request'

configure({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  adapter: axiosAdapter,
  cacheAdapter: indexedDBAdapter,
  headers: {
    'Content-Type': 'application/json',
  },
  retry: {
    count: 3,
    delay: 1000,
  },
  onBefore: (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`,
      }
    }
  },
  onSuccess: (response) => {
    console.log('请求成功:', response)
  },
  onError: (err) => {
    if (err.status === 401) {
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
    console.error('请求失败:', err)
  },
  onFinally: () => {
    console.log('请求完成')
  },
})
```

单个请求可以覆盖全局配置：

```typescript
const { send } = useRequest({
  url: '/api/users',
  timeout: 5000,
  headers: {
    'X-Custom-Header': 'custom-value',
  },
  onSuccess: (response) => {
    console.log('用户数据:', response.data)
  },
})
```

### 请求重试

```typescript
const { send } = useRequest({
  url: '/api/data',
  retry: {
    count: 3,
    delay: 1000,
  },
  onSuccess: (response) => {
    console.log('数据获取成功:', response.data)
  },
  onError: (err) => {
    console.error('请求失败:', err)
  },
})
```

### 请求缓存

默认使用 localStorage 作为缓存存储，无需额外安装：

```typescript
const { send } = useRequest({
  url: '/api/users',
  cache: {
    key: 'users-list',
    ttl: 5 * 60 * 1000,
  },
  onSuccess: (response) => {
    console.log('用户列表:', response.data)
  },
})
```

### 缓存适配器

项目支持多种缓存适配器，可以根据需求选择合适的存储方式。

#### LocalStorage 适配器（默认）

LocalStorage 适配器是默认的缓存适配器，无需额外安装，适合大多数场景。如果不指定适配器，将自动使用 localStorage：

```typescript
import { useRequest } from 'wl-request'
import { localStorageAdapter } from 'wl-request'

const { send } = useRequest({
  url: '/api/users',
  cache: {
    key: 'users-list',
    ttl: 5 * 60 * 1000,
    cacheAdapter: localStorageAdapter,
  },
  onSuccess: (response) => {
    console.log('用户列表:', response.data)
  },
})
```

#### 内存适配器

内存适配器将数据存储在内存中，页面刷新后数据会丢失，适合临时缓存场景：

```typescript
import { useRequest } from 'wl-request'
import { memoryAdapter } from 'wl-request'

const { send } = useRequest({
  url: '/api/users',
  cache: {
    key: 'users-list',
    ttl: 5 * 60 * 1000,
    cacheAdapter: memoryAdapter,
  },
  onSuccess: (response) => {
    console.log('用户列表:', response.data)
  },
})
```

#### IndexedDB 适配器

IndexedDB 适配器适合存储大量数据，支持更大的存储空间：

```typescript
import { useRequest } from 'wl-request'
import { indexedDBAdapter } from 'wl-request'

const { send } = useRequest({
  url: '/api/users',
  cache: {
    key: 'users-list',
    ttl: 5 * 60 * 1000,
    cacheAdapter: indexedDBAdapter,
  },
  onSuccess: (response) => {
    console.log('用户列表:', response.data)
  },
})
```

#### 全局配置缓存适配器

可以在全局配置中设置默认的缓存适配器，所有使用缓存的请求都会使用该适配器：

```typescript
import { configure } from 'wl-request'
import { indexedDBAdapter } from 'wl-request'

configure({
  cacheAdapter: indexedDBAdapter,
})
```

#### 适配器选择建议

- **LocalStorage**：默认选择，适合大多数场景，存储容量约 5-10MB
- **内存适配器**：适合临时数据，页面刷新后自动清除，性能最好
- **IndexedDB**：适合大量数据缓存，存储容量可达数百 MB，但 API 较复杂

### 并行请求

```typescript
import { useParallelRequests } from 'wl-request'

const { send } = useParallelRequests(
  [{ url: '/api/users' }, { url: '/api/posts' }, { url: '/api/comments' }],
  {
    onBefore: () => {
      console.log('开始并行请求')
    },
    onSuccess: (results) => {
      console.log('所有请求完成:', results)
    },
    onError: (errors) => {
      console.error('部分请求失败:', errors)
    },
    onFinally: () => {
      console.log('并行请求完成')
    },
  }
)
```

### 串行请求

```typescript
import { useSerialRequests } from 'wl-request'

const { send } = useSerialRequests(
  [{ url: '/api/step1' }, { url: '/api/step2' }, { url: '/api/step3' }],
  {
    onBefore: () => {
      console.log('开始串行请求')
    },
    onSuccess: (results) => {
      console.log('所有请求完成:', results)
    },
    onError: (error, index) => {
      console.error(`第 ${index + 1} 个请求失败:`, error)
    },
    onFinally: () => {
      console.log('串行请求完成')
    },
  }
)
```

### 幂等请求

幂等请求使用缓存机制来确保相同请求在指定时间内只执行一次，可以配置缓存适配器：

```typescript
const { send } = useRequest({
  url: '/api/create-order',
  method: 'POST',
  idempotent: {
    key: 'order-123',
    ttl: 10 * 60 * 1000,
  },
  onSuccess: (response) => {
    console.log('订单创建成功:', response.data)
  },
  onError: (err) => {
    console.error('订单创建失败:', err)
  },
})
```

#### 使用自定义缓存适配器

幂等请求支持指定缓存适配器，默认使用全局配置的缓存适配器或 localStorage：

```typescript
import { useRequest } from 'wl-request'
import { memoryAdapter } from 'wl-request'

const { send } = useRequest({
  url: '/api/create-order',
  method: 'POST',
  idempotent: {
    key: 'order-123',
    ttl: 10 * 60 * 1000,
    cacheAdapter: memoryAdapter,
  },
  onSuccess: (response) => {
    console.log('订单创建成功:', response.data)
  },
})
```

使用 IndexedDB 适配器存储幂等请求记录：

```typescript
import { useRequest } from 'wl-request'
import { indexedDBAdapter } from 'wl-request'

const { send } = useRequest({
  url: '/api/create-order',
  method: 'POST',
  idempotent: {
    key: 'order-123',
    ttl: 10 * 60 * 1000,
    cacheAdapter: indexedDBAdapter,
  },
  onSuccess: (response) => {
    console.log('订单创建成功:', response.data)
  },
})
```

### 使用自定义适配器（Axios）

```typescript
import { useRequest } from 'wl-request'
import { axiosAdapter } from '@wl-request/adapter-axios'

const { send } = useRequest({
  url: '/api/users',
  adapter: axiosAdapter,
  onSuccess: (response) => {
    console.log('数据获取成功:', response.data)
  },
  onError: (err) => {
    console.error('请求失败:', err)
  },
})
```

## 架构设计

### 分层架构

1. **接口层**：定义统一的请求接口和类型
2. **适配器层**：实现不同请求库的适配器
3. **功能层**：实现重试、缓存、并行/串行等高级功能
4. **Hook 层**：提供 Hooks 封装，方便在组件中使用

### 依赖倒置原则

- 核心包不依赖具体的请求库实现
- 通过适配器接口实现解耦
- 适配器包独立维护，可按需安装

## 适配器开发

开发新的适配器需要实现统一的适配器接口，确保完全兼容原请求库的 API 和行为。

## 测试

项目包含完善的单元测试和集成测试，确保功能的稳定性和可靠性。
